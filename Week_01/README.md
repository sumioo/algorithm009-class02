# 学习笔记

## 算法题知识点总结
第一周学习了两种基本数据结构数组和链表，数组的优势在于随机访问和能有效利用计算机缓存的局部性原理，缺点在于插入和删除都要移动相邻数据。链表的插入和删除操作都是常数时间，
链表可以有单向链表，双向链表，循环链表，在编程中常使用哑结点作为哨兵节点简化代码。
基于数组和链表可以构造两种抽象数据结构栈和队列，根据不同场景下得性能要求可以选择合适的底层数据结构。deque即双端队列，可同时用作栈和队列。
在以链表和数组的算法题中较多的使用双指针的技巧，常用的有快慢指针和两边夹逼指针。

## 栈、队列

### 概述

栈和队列是一种抽象的数据结构，在实现可以用数组或链表。
栈是一种先进后出的抽象数据结构，可以用现实世界中堆盘子来类比。
常用来解决符号配对、算术运算。操作系统使用栈来进行函数调用

队列是一种先进先出的抽象数据结构，可以用现实世界中排队来类比。
可以用来缓冲并发访问，留新去旧


### 栈API

* peek() 查看栈顶元素
* push() 入栈
* pop() 出栈


### 队列API

* add() 在队头加入
* remove() 在队尾删除
* isEmpty() 是否为空


#### 链表实现

* 好处：没有容量限制，插入和删除都是常数时间
* 坏处：插入需要申请内存，删除需要释放内存，频繁的插入和删除很耗费性能

#### 数组实现

* 好处：插入和删除不需要进行内存管理，可有效利用局部性原理
* 坏处：如果队列没用容量限制，则在队列满的时候需要进行扩容，一般是直接扩容当前容量两倍。

#### 顺序循环队列 （数组实现）

front为队首指针，rear为队尾指针，从队尾入队，rear+1

##### 如何判断队列为空？
front == rear 初始化时front、rear指向同一个位置

##### 如何判断队列是否已满？
为了避免“队列为空”和“队列为满”的判别条件冲突, 数组少用一个存储单元，(rear+1)%capacity == front

##### front、rear循环
* rear = (rear+1)%capacity
* front = (front+1)%capacity

#### 循环双端队列 （数组实现）

在实现上和顺序循环队列一样

##### 定义循环变量 front 和 rear

* front：指向队列头部第 1 个有效数据的位置；
* rear：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。

##### 为了避免“队列为空”和“队列为满”的判别条件冲突，有意浪费了一个位置
浪费一个位置是指：循环数组中任何时刻一定至少有一个位置不存放有效元素。

判别队列为空的条件是：front == rear;；

判别队列为满的条件是：(rear + 1) % capacity == front;。可以这样理解，当 rear 循环到数组的前面，要从后面追上 front，还差一格的时候，判定队列为满。

##### 因为有循环的出现，要特别注意处理数组下标可能越界的情况。
* 指针后移的时候，索引 + 1，要取模；
* 指针前移的时候，为了循环到数组的末尾，需要先加上数组的长度，然后再对数组长度取模。
